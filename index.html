<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Map style Pokémon Diamant — demo</title>
  <style>
    :root{--tile:32px;--scale:2}
    html,body{height:100%;margin:0;background:#2b2f33;display:flex;align-items:center;justify-content:center;font-family:Inter,system-ui,Arial}
    .stage{background:#9bbf6b;padding:12px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.6);}
    canvas{display:block;background:#8fc54c;border:6px solid #3a5a2a;border-radius:8px; image-rendering: pixelated; width: calc(var(--tile) * 20 * var(--scale)); height: calc(var(--tile) * 15 * var(--scale));}
    .ui{display:flex;gap:8px;justify-content:center;margin-top:8px}
    button{background:#fff;border:0;padding:6px 10px;border-radius:6px;cursor:pointer}
    .legend{color:#fff;font-size:13px;margin-top:6px;text-align:center}
    code{background:rgba(255,255,255,.06);padding:2px 6px;border-radius:4px}
  </style>
</head>
<body>
  <div class="stage">
    <canvas id="map" width="640" height="480"></canvas>
    <div class="ui">
      <button id="zoomIn">Zoom +</button>
      <button id="zoomOut">Zoom −</button>
      <button id="toggleGrid">Grille</button>
      <button id="center">Recentrer</button>
    </div>
    <div class="legend">Touches: <code>ZQSD</code> ou flèches — Clic pour téléporter — Map stylisée façon Pokémon Diamant</div>
  </div>

<script>
// === Configuration ===
const tileSize = 32; // base tile size in px
const canvas = document.getElementById('map');
const ctx = canvas.getContext('2d');
let SCALE = 2; // visually scale the canvas using CSS (keeps pixel art sharp)
const VIEW_TILES_X = 20; // how many tiles shown horizontally
const VIEW_TILES_Y = 15; // vertically

// camera in pixels
const camera = { x:0, y:0 };

// simple tileset: 0=grass,1=path,2=water,3=tree,4=rock,5=flower
const tileNames = ['herbe','chemin','eau','arbre','roche','fleurs'];

// A small map array (W x H) using numbers above. You can edit this array to design your map.
const MAP = [
  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
  [2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2],
  [2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2],
  [2,2,2,2,1,0,3,3,0,0,5,0,0,4,0,0,1,2,2,2,2,2,2,2],
  [2,2,2,2,1,0,3,3,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2],
  [2,2,2,2,1,0,0,0,0,0,0,0,4,0,0,0,1,2,2,2,2,2,2,2],
  [2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2],
  [2,2,2,2,2,2,2,1,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2],
  [2,2,2,2,2,2,2,1,0,4,0,0,3,0,1,2,2,2,2,2,2,2,2,2],
  [2,2,2,2,2,2,2,1,0,0,0,0,0,5,1,2,2,2,2,2,2,2,2,2],
  [2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2],
  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
];

const MAP_H = MAP.length;
const MAP_W = MAP[0].length;

// Player
const player = {
  tx: 3, ty: 4, // tile coords
  x: 3 * tileSize + tileSize/2,
  y: 4 * tileSize + tileSize/2,
  speed: 140, // pixels per second
  size: 18
};

// Controls
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('click', e => {
  // teleport to clicked tile for quick testing
  const rect = canvas.getBoundingClientRect();
  const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
  const worldX = camera.x + cx;
  const worldY = camera.y + cy;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);
  if (tx >=0 && tx < MAP_W && ty >=0 && ty < MAP_H){
    player.x = tx * tileSize + tileSize/2;
    player.y = ty * tileSize + tileSize/2;
  }
});

// Helpers
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function isSolidTile(t){ // simple collision: trees and water and rock are solid
  return t===2 || t===3 || t===4;
}

// Draw one tile at tile coordinates tx,ty at screen coords sx,sy
function drawTile(t, sx, sy){
  const s = tileSize;
  ctx.save();
  ctx.translate(sx, sy);
  // base ground
  if (t===0){ // grass
    ctx.fillStyle = '#7fc844';
    ctx.fillRect(0,0,s,s);
    // little darker patches
    ctx.fillStyle = '#6fbe3a';
    for(let i=0;i<3;i++) ctx.fillRect(Math.random()*s, Math.random()*s, 4, 4);
  } else if (t===1){ // path
    ctx.fillStyle = '#d6b48b'; ctx.fillRect(0,0,s,s);
    ctx.strokeStyle = '#b8926e'; ctx.lineWidth=2; ctx.strokeRect(2,2,s-4,s-4);
  } else if (t===2){ // water
    ctx.fillStyle = '#5aa8df'; ctx.fillRect(0,0,s,s);
    // waves
    ctx.fillStyle='rgba(255,255,255,0.08)';
    for(let i=0;i<2;i++) ctx.fillRect(i*8+4,8,6,2);
  } else if (t===3){ // tree over grass
    ctx.fillStyle = '#7fc844'; ctx.fillRect(0,0,s,s);
    // trunk
    ctx.fillStyle='#6b4a2b'; ctx.fillRect(s/2-4,s-12,8,12);
    // leaves
    ctx.beginPath(); ctx.fillStyle='#1f8b2b'; ctx.ellipse(s/2, s/2 -2, 12, 10, 0, 0, Math.PI*2); ctx.fill();
  } else if (t===4){ // rock
    ctx.fillStyle = '#7fc844'; ctx.fillRect(0,0,s,s);
    ctx.fillStyle = '#6e6e6e'; ctx.beginPath(); ctx.arc(s/2, s/2, 8, 0, Math.PI*2); ctx.fill();
  } else if (t===5){ // flowers
    ctx.fillStyle = '#7fc844'; ctx.fillRect(0,0,s,s);
    ctx.fillStyle='#ff4f8b'; ctx.fillRect(8,12,4,4); ctx.fillRect(18,8,4,4);
  } else {
    ctx.fillStyle='#ff00ff'; ctx.fillRect(0,0,s,s);
  }
  ctx.restore();
}

// Render entire visible area
function render(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const startCol = Math.floor(camera.x / tileSize);
  const startRow = Math.floor(camera.y / tileSize);
  const endCol = Math.ceil((camera.x + canvas.width) / tileSize);
  const endRow = Math.ceil((camera.y + canvas.height) / tileSize);

  for(let row = startRow; row < endRow; row++){
    for(let col = startCol; col < endCol; col++){
      const sx = col * tileSize - camera.x;
      const sy = row * tileSize - camera.y;
      if (row>=0 && row<MAP_H && col>=0 && col<MAP_W){
        drawTile(MAP[row][col], sx, sy);
      } else {
        ctx.fillStyle='#2a8ee0'; ctx.fillRect(sx,sy,tileSize,tileSize);
      }
    }
  }

  // draw player shadow
  ctx.fillStyle='rgba(0,0,0,0.2)';
  ctx.beginPath(); ctx.ellipse(player.x - camera.x, player.y - camera.y + 12, player.size/1.8, player.size/3.5, 0, 0, Math.PI*2); ctx.fill();
  // draw player (simple sprite)
  ctx.save();
  ctx.translate(player.x - camera.x, player.y - camera.y);
  // body
  ctx.fillStyle='#ffebcd'; ctx.fillRect(-6,-12,12,14);
  // hat
  ctx.fillStyle='#d62828'; ctx.fillRect(-8,-20,16,8);
  // face
  ctx.fillStyle='#3c3c3c'; ctx.fillRect(-3,-8,2,2); ctx.fillRect(1,-8,2,2);
  ctx.restore();

  // debug grid
  if (SHOW_GRID){
    ctx.strokeStyle='rgba(0,0,0,0.18)'; ctx.lineWidth=1;
    for(let x=0;x<=canvas.width;x+=tileSize){ ctx.beginPath(); ctx.moveTo(x+.5,0); ctx.lineTo(x+.5,canvas.height); ctx.stroke(); }
    for(let y=0;y<=canvas.height;y+=tileSize){ ctx.beginPath(); ctx.moveTo(0,y+.5); ctx.lineTo(canvas.width,y+.5); ctx.stroke(); }
  }
}

let last = performance.now();
let SHOW_GRID = false;

function update(dt){
  // movement with arrow keys or ZQSD
  let dx=0, dy=0;
  if (keys['arrowup'] || keys['z']) dy -= 1;
  if (keys['arrowdown'] || keys['s']) dy += 1;
  if (keys['arrowleft'] || keys['q']) dx -= 1;
  if (keys['arrowright'] || keys['d']) dx += 1;
  // normalize
  if (dx !== 0 && dy !== 0){ dx *= Math.SQRT1_2; dy *= Math.SQRT1_2; }
  const nextX = player.x + dx * player.speed * dt;
  const nextY = player.y + dy * player.speed * dt;

  // collision check: check the tile center we would occupy
  const tileX = Math.floor(nextX / tileSize);
  const tileY = Math.floor(nextY / tileSize);
  if (tileX>=0 && tileX<MAP_W && tileY>=0 && tileY<MAP_H){
    if (!isSolidTile(MAP[tileY][tileX])){
      player.x = nextX; player.y = nextY;
    } else {
      // try axis-separated movement to allow sliding along obstacles
      const tileXonly = Math.floor(nextX / tileSize);
      const tileYonly = Math.floor(player.y / tileSize);
      if (!isSolidTile(MAP[tileYonly][tileXonly])) player.x = nextX;
      const tileXonly2 = Math.floor(player.x / tileSize);
      const tileYonly2 = Math.floor(nextY / tileSize);
      if (!isSolidTile(MAP[tileYonly2][tileXonly2])) player.y = nextY;
    }
  }

  // camera follows player (center)
  camera.x = player.x - canvas.width / 2;
  camera.y = player.y - canvas.height / 2;
  // clamp camera to map bounds
  camera.x = clamp(camera.x, 0, MAP_W*tileSize - canvas.width);
  camera.y = clamp(camera.y, 0, MAP_H*tileSize - canvas.height);
}

function loop(now){
  const dt = (now - last) / 1000; last = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// initialize canvas pixel size based on tile & view and scale
function resizeCanvas(){
  canvas.width = tileSize * VIEW_TILES_X;
  canvas.height = tileSize * VIEW_TILES_Y;
  canvas.style.width = (tileSize * VIEW_TILES_X * SCALE) + 'px';
  canvas.style.height = (tileSize * VIEW_TILES_Y * SCALE) + 'px';
}
resizeCanvas();

// UI
document.getElementById('zoomIn').addEventListener('click', ()=>{ SCALE = clamp(SCALE+0.5,1,4); resizeCanvas(); });
document.getElementById('zoomOut').addEventListener('click', ()=>{ SCALE = clamp(SCALE-0.5,1,4); resizeCanvas(); });
document.getElementById('toggleGrid').addEventListener('click', ()=>{ SHOW_GRID = !SHOW_GRID; });
document.getElementById('center').addEventListener('click', ()=>{ camera.x = player.x - canvas.width/2; camera.y = player.y - canvas.height/2; camera.x = clamp(camera.x, 0, MAP_W*tileSize - canvas.width); camera.y = clamp(camera.y, 0, MAP_H*tileSize - canvas.height); });

// start loop
requestAnimationFrame(loop);

// Helpful notes for customization (visible in dev console)
console.log('Map loaded — éditer la constante MAP dans le code pour changer la carte.');
console.log('tile index:', tileNames);
</script>
</body>
</html>
